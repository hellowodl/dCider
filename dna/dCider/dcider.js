'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

function ProposalCreate (ProposalEntry) {
  var ProposalHash = commit("Proposal", ProposalEntry);
  return ProposalHash;
}

function ProposalRead (options) {
  var Proposal = get(options.hash);
  return Proposal;
}

function ProposalUpdate (ProposalHash) {
  var sampleValue={"name":"lets get drunk","description":"great proposal","options":["hella nah","hellah yeah"],"extraField":true};
  var ProposalOutHash = update("Proposal", sampleValue, ProposalHash);
  return ProposalOutHash;
}

function delegate (params) {
	console.log(App.Key.Hash);
	console.log(params.hash);
  var delegateHash = commit("Delegate", { Links: [ { Base: App.Key.Hash, Link: params.hash, Tag: "Delegate" } ]});
  var delegateMirrorHash = commit("DelegateMirror", { Links: [ { Base: params.hash, Link: App.Key.Hash, Tag: "DelegateMirror" } ]});
  // your custom code here
  return { "delegateHash" : delegateHash , "delegateMirrorHash" : delegateMirrorHash };
}

// don't bother
function withdraw (params) {
	console.log(App.Key.Hash);
  var resultWithdraw = {"delegateHash":"","delegateMirrorHash":""};
  var delegations = getLinks( App.Key.Hash , "Delegate", { Load: true } );

  console.log(JSON.stringify(delegations));

  if ( delegations.length == 1 ) {
    delegatee = delegations[0].Hash;

	delegationMirrors = getLinks( delegatee , "DelegateMirror" ).filter( function(x) { return x.Hash == App.Key.Hash } );

	resultWithdraw.delegateHash = remove( delegatee, 'withdrew delegation' );
	if ( delegationMirrors.length == 1 ) {
		resultWithdraw.delegateMirrorHash = remove( delegationMirrors[0] );
	}
  }
  return resultWithdraw;
}

function removeVote(params) {
  var proposalHash = params.hash;
  var oldVoteMirrorHash = "";
  var oldVoteHash = "";

  // remove old vote if there:
  var votes = getLinks( App.Key.Hash , "" ,{ Load: true });
  votes = votes.filter( function(x) { return x.Hash === proposalHash });
  
  // if we find a vote for the same proposal, remove it first
  if (votes.length > 0) {
    voteMirrors = getLinks( proposalHash , "", { Load: true });
    voteMirrors = voteMirrors.filter( function(x) { return x.Hash === App.Key.Hash });
    // remove the back link
    if (voteMirrors > 0) {
      oldVoteMirrorHash = commit("VoteMirror", { Links: [ { 
        Base: proposalHash, 
        Link: App.Key.Hash, 
        Tag: voteMirrors[0].Tag , 
        LinkAction: HC.LinkAction.Del 
     } ]});
    }
    oldVoteHash = commit("Vote", { Links: [ { 
      Base: App.Key.Hash, 
      Link: proposalHash, 
      Tag: votes[0].Tag , 
      LinkAction: HC.LinkAction.Del } ]});
  }
  
  return { oldVoteHash: oldVoteHash, oldVoteMirrorHash: oldVoteMirrorHash };
}

function vote (params) {
  var proposalHash = params.hash;
  var choiceNum = params.choice;
  var oldVoteMirrorHash = "";
  var oldVoteHash = "";

  // remove old vote if there:
  var removeOldReturn = removeVote( params );

  // create new vote:
  var voteHash = commit("Vote", { Links: [ { Base: App.Key.Hash, Link: proposalHash, Tag: choiceNum.toString() } ]});
  var voteMirrorHash = commit("VoteMirror", { Links: [ { 
    Base: proposalHash, 
    Link: App.Key.Hash, 
    Tag: choiceNum.toString() 
  } ]});
  
  return { oldVoteHash: removeOldReturn.oldVoteHash, oldVoteMirrorHash: removeOldReturn.oldVoteMirrorHash, voteHash: voteHash, voteMirrorHash: voteMirrorHash };
}

function countVotes (proposalHash) {
    const res = {},
          votes = getLinks(proposalHash, '', { Load: true })

    votes.map(function (vote) {
      return vote.Tag
    }).forEach(function (x) {
        res[x] = (res[x] || 0)+1
    })

    return res
}


// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis () {
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod (entryName, entry, header, replaces, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel (entryName, hash, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink (entryName, baseHash, links, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg (entryName) {
  return null;
}