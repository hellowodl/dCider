'use strict';

// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

function ProposalCreate (ProposalEntry) {
  var ProposalHash = commit("Proposal", ProposalEntry);
  return ProposalHash;
}

function ProposalRead (options) {
  var Proposal = get(options.hash);
  return Proposal;
}

function ProposalUpdate (ProposalHash) {
  var sampleValue={"name":"lets get drunk","description":"great proposal","options":["hella nah","hellah yeah"],"extraField":true};
  var ProposalOutHash = update("Proposal", sampleValue, ProposalHash);
  return ProposalOutHash;
}

function delegate (params) {
  // remove old delegation if relevant
  var removeOldDelegation = withdraw (params);
  
  // make new delegation
  var delegateHash = commit("Delegate", { Links: [ { Base: App.Key.Hash, Link: params.hash, Tag: "Delegate" } ]});
  var delegateMirrorHash = commit("DelegateMirror", { Links: [ { Base: params.hash, Link: App.Key.Hash, Tag: "DelegateMirror" } ]});
  
  // return hashes
  return { 
    "oldDelegateHash": removeOldDelegation.oldDelegateHash, 
    "oldDelegateMirrorHash": removeOldDelegation.oldDelegateMirrorHash, 
    "delegateHash" : delegateHash , 
    "delegateMirrorHash" : delegateMirrorHash };
}

// don't bother
function withdraw (params) {
  var resultWithdraw = {"oldDelegateHash":"","oldDelegateMirrorHash":""};
  var delegations = getLinks( App.Key.Hash , "Delegate", { Load: true } );

  if ( delegations.length == 1 ) {
    delegatee = delegations[0].Hash;

	  delegationMirrors = getLinks( delegatee , "DelegateMirror" ).filter( function(x) { return x.Hash == App.Key.Hash } );

	  if ( delegationMirrors.length == 1 ) {
		  resultWithdraw.oldDelegateMirrorHash = commit("DelegateMirror", { Links: [ { Base: delegatee, Link: App.Key.Hash, Tag: "DelegateMirror" , LinkAction: HC.LinkAction.Del } ]});
	  }
	  resultWithdraw.oldDelegateHash = commit("Delegate", { Links: [ { Base: App.Key.Hash, Link: delegatee, Tag: "Delegate" , LinkAction: HC.LinkAction.Del } ]});
  }
  return resultWithdraw;
}

function removeVote(params) {
  var proposalHash = params.hash;
  var oldVoteMirrorHash = "";
  var oldVoteHash = "";

  // remove old vote if there:
  var votes = getLinks( App.Key.Hash , "" ,{ Load: true });
  votes = votes.filter( function(x) { return x.Hash === proposalHash });
  
  // if we find a vote for the same proposal, remove it first
  if (votes.length > 0) {
    voteMirrors = getLinks( proposalHash , "", { Load: true });
    voteMirrors = voteMirrors.filter( function(x) { return x.Hash === App.Key.Hash });
    // remove the back link
    if (voteMirrors.length > 0) {
      oldVoteMirrorHash = commit("VoteMirror", { Links: [ { 
        Base: proposalHash, 
        Link: App.Key.Hash, 
        Tag: voteMirrors[0].Tag , 
        LinkAction: HC.LinkAction.Del 
     } ]});
    }
    oldVoteHash = commit("Vote", { Links: [ { 
      Base: App.Key.Hash, 
      Link: proposalHash, 
      Tag: votes[0].Tag , 
      LinkAction: HC.LinkAction.Del } ]});
  }
  
  return { oldVoteHash: oldVoteHash, oldVoteMirrorHash: oldVoteMirrorHash };
}

function vote (params) {
  var proposalHash = params.hash;
  var choiceNum = params.choice;
  var oldVoteMirrorHash = "";
  var oldVoteHash = "";

  // remove old vote if there:
  var removeOldReturn = removeVote( params );

  // create new vote:
  var voteHash = commit("Vote", { Links: [ { Base: App.Key.Hash, Link: proposalHash, Tag: choiceNum.toString() } ]});
  var voteMirrorHash = commit("VoteMirror", { Links: [ { 
    Base: proposalHash, 
    Link: App.Key.Hash, 
    Tag: choiceNum.toString() 
  } ]});
  
  return { oldVoteHash: removeOldReturn.oldVoteHash, oldVoteMirrorHash: removeOldReturn.oldVoteMirrorHash, voteHash: voteHash, voteMirrorHash: voteMirrorHash };
}

function countDelegatedVotes(params) {
  var hasVoted = params.hasVoted;
  var res = params.res;
  var startNode = params.nodeHash;
  var choice = params.choice;

  delegations = getLinks( startNode , "DelegateMirror" ).map(function(x){return x.Hash})
  delegations = delegations.filter( function(delegator) { return hasVoted.indexOf(delegator) < 0 } ) ;

  delegations.forEach( function(delegator) {
    res[choice] = (res[choice] || 0)+1;
    res = countDelegatedVotes( {
        hasVoted: hasVoted,
        res: res,
        nodeHash: delegator,
        choice: choice
        } )
  } )

  return res
}

function countVotes (params) {
    var res = {},
        votes = getLinks(params.hash, '', { Load: true });

    votes.map(function (vote) {
      return Number(vote.Tag)
    }).forEach(function (x) {
        res[x] = (res[x] || 0)+1
    })
    
    hasVoted = votes.map(function (vote) {
      return vote.Hash})
    
    votes.forEach(function(vote) {
      res = countDelegatedVotes( {
        hasVoted: hasVoted,
        res: res,
        nodeHash: vote.Hash,
        choice: Number(vote.Tag)
        } ) 
      } )

    return res
}


// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis () {
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut (entryName, entry, header, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod (entryName, entry, header, replaces, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel (entryName, hash, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink (entryName, baseHash, links, pkg, sources) {
  switch (entryName) {
    case "Proposal":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Vote":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "VoteMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "Delegate":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    case "DelegateMirror":
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return true;
    default:
      // invalid entry name
      return true;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg (entryName) {
  return null;
}